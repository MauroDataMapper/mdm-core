import java.lang.management.ManagementFactory
import java.lang.management.RuntimeMXBean
import java.util.concurrent.TimeUnit

// Use the pathing jar if running in windows. This is needed otherwise the classpath is too long for the idiotic windows OS
grails {
    if (org.gradle.internal.os.OperatingSystem.current() == org.gradle.internal.os.OperatingSystem.WINDOWS) {
        logger.quiet('Using pathing Jar as running in Windows OS')
        pathingJar = true
    }
}

// Ensure the compile task in gradle runs all the classes tasks.
compile.dependsOn(tasks.findAll {it.name.toLowerCase().endsWith('classes')})

/*
 Create a way of only running integration tests and only running functional tests
 Whilst these should be inside separate source directories and a new task created, this approach is not the grails way, but we do not want
 to execute any functional tests until the integration ones have passed.
*/
boolean integrationTests = true
boolean functionalTests = true

if (System.getProperty('grails.integrationTest')) {
    integrationTests = System.getProperty('grails.integrationTest').toBoolean()
    functionalTests = !integrationTests
}
if (System.getProperty('grails.functionalTest')) {
    functionalTests = System.getProperty('grails.functionalTest').toBoolean()
    integrationTests = !functionalTests
}

if (tasks.findByName('integrationTest')) {

    configurations {
        integrationTestImplementation {
            extendsFrom testImplementation
        }
    }

    if (integrationTests && !functionalTests) {
        logger.log(LogLevel.WARN, '<<>> Running integration tests only <<>>')
        integrationTest {
            //            useJUnit {
            //                includeCategories 'uk.ac.ox.softeng.maurodatamapper.test.junit.IntegrationTest'
            //                excludeCategories 'uk.ac.ox.softeng.maurodatamapper.test.junit.FunctionalTest'
            //            }
            filter{
                excludeTestsMatching '*FunctionalSpec'
            }
        }
    } else if (functionalTests && !integrationTests) {
        logger.log(LogLevel.WARN, '<<>> Running functional tests only <<>>')
        integrationTest {
            binaryResultsDirectory.set(file("${project.testResultsDir}/functionalTest/binary"))
            //            useJUnit {
            //                excludeCategories 'uk.ac.ox.softeng.maurodatamapper.test.junit.IntegrationTest'
            //                includeCategories 'uk.ac.ox.softeng.maurodatamapper.test.junit.FunctionalTest'
            //            }
            filter{
                includeTestsMatching '*FunctionalSpec'
            }
            reports {
                junitXml.destination = file("${project.testResultsDir}/functionalTest")

            }
        }
        mergeTestReports.reportOn(file("${project.testResultsDir}/functionalTest/binary"))
    }
}

task('cleanTestResults', type: Delete) {
    group 'clean'
    delete 'build/test-results'
}


task('jenkinsClean') {
    group 'clean'
    dependsOn tasks.cleanLogs
    dependsOn tasks.cleanTestResults
    dependsOn tasks.cleanReports
}

test {
    systemProperty 'grails.root.base.dir', rootDir.absolutePath
    maxParallelForks = Runtime.runtime.availableProcessors().intdiv(2) ?: 1
}

if (tasks.findByName('mergeTestReports')) {
    logger.info('Merging test reports')
    test {
        finalizedBy tasks.getByName('mergeTestReports')
        // Turn off the HTML report as this will be generated now in the correct place by the mergeTestReports task
        reports {
            html {
                enabled false
            }
        }
    }
}else{
    logger.quiet("Fixing test report path to ${file("${buildDir}/reports/tests/index.html")}")
    test{
        reports{
            html{
                destination = file("${buildDir}/reports/tests")
            }
        }
    }
}

// Handle "implementation" dependencies into the compile views tasks
AbstractCompile compile = tasks.findByName('compileGsonViews') as AbstractCompile
if (compile) {
    compile.setClasspath(compile.getClasspath() + configurations.compileClasspath)
}

compile = tasks.findByName('compileGmlViews') as AbstractCompile
if (compile) {
    compile.setClasspath(compile.getClasspath() + configurations.compileClasspath)
}

configurations {
    publishToArtifactory
}

if(!name.contains('testing')) {
    javadoc {
        if (JavaVersion.current().isJava9Compatible()) {
            options.addBooleanOption('html5', true)
        }
    }
}

task('sysProps') {
    group 'help'
    doLast {
        logger.quiet('{}', System.properties.collect {"${it.key}:${it.value}"}.sort().join('\n'))
    }
}

task('jvmArgs') {
    group 'help'
    doLast {
        RuntimeMXBean runtimeMxBean2 = ManagementFactory.getRuntimeMXBean()
        logger.quiet('{}', runtimeMxBean2.getInputArguments().join('\n'))
    }
}

license {
    header = file("${rootDir}/NOTICE")
    excludes([
        '**/*.gson',
        '**/*.yml',
        '**/META-INF/**',
        '**/*.txt',
        '**/*.json',
        '**/*.gml',
        '**/*.jpeg',
        '**/*.png',
        '**/*.xml'
    ])
}

project.afterEvaluate {

    project.tasks.withType(JavaCompile) {JavaCompile c ->
        c.options.fork = true
        c.options.encoding = 'UTF-8'
        //compile.options.incremental = useIncrementalJavaBuilding.toBoolean()
        c.options.compilerArgs.add('-Xlint:unchecked')
        c.options.compilerArgs.add('-Xlint:deprecation')
    }
    project.tasks.withType(GroovyCompile) {GroovyCompile c ->
        c.options.fork = true
        c.options.encoding = 'UTF-8'
    }
    project.tasks.withType(Jar) {
        Map attrs = [
            "Created-By"            : "${JavaVersion.current().toString()} JVM, ${project.gradle.gradleVersion} Gradle",
            "Specification-Title"   : "$project.rootProject.name $project.name Classes",
            "Specification-Version" : project.version,
            "Implementation-Title"  : "${project.group.toLowerCase()}.${project.name.toLowerCase()}",
            "Implementation-Version": "${project.version}.dev",
            "Implementation-Vendor" : "Oxford University",
        ]
        if (project.hasProperty('mainClass'))
            attrs.'Main-Class' = project.mainClass

        manifest {
            attributes(attrs)
        }
        // sourceCompatibility = project.sourceCompatibility
        group 'archives'
    }

    artifactory {
        publish {
            defaults {
                publications('maven')
                publishBuildInfo = true
                publishArtifacts = true
                publishPom = true
            }
        }
    }

}